// Generated by CoffeeScript 1.6.2
(function() {
  var DEBUG, shared,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DEBUG = true;

  shared = window;

  shared.MMIXCommands = (function() {
    function MMIXCommands(memory, registers, processor) {
      this.nxor = __bind(this.nxor, this);
      this.nand = __bind(this.nand, this);
      this.andn = __bind(this.andn, this);
      this.and = __bind(this.and, this);
      this.xor = __bind(this.xor, this);
      this.nor = __bind(this.nor, this);
      this.orn = __bind(this.orn, this);
      this.or = __bind(this.or, this);
      this.stou = __bind(this.stou, this);
      this.sttu = __bind(this.sttu, this);
      this.stt = __bind(this.stt, this);
      this.stwu = __bind(this.stwu, this);
      this.stw = __bind(this.stw, this);
      this.stbu = __bind(this.stbu, this);
      this.stb = __bind(this.stb, this);
      this.ldou = __bind(this.ldou, this);
      this.ldtu = __bind(this.ldtu, this);
      this.ldt = __bind(this.ldt, this);
      this.ldwu = __bind(this.ldwu, this);
      this.ldw = __bind(this.ldw, this);
      this.ldbu = __bind(this.ldbu, this);
      this.ldb = __bind(this.ldb, this);
      this.sub = __bind(this.sub, this);
      this.add = __bind(this.add, this);
      this.mul = __bind(this.mul, this);
      this.mulu = __bind(this.mulu, this);
      this.fint = __bind(this.fint, this);
      this.frem = __bind(this.frem, this);
      this.fsqrt = __bind(this.fsqrt, this);
      this.fdiv = __bind(this.fdiv, this);
      this.feqle = __bind(this.feqle, this);
      this.fune = __bind(this.fune, this);
      this.fcmpe = __bind(this.fcmpe, this);
      this.fmul = __bind(this.fmul, this);
      this.sflotu = __bind(this.sflotu, this);
      this.sflot = __bind(this.sflot, this);
      this.flotu = __bind(this.flotu, this);
      this.flot = __bind(this.flot, this);
      this.fixu = __bind(this.fixu, this);
      this.fsub = __bind(this.fsub, this);
      this.fix = __bind(this.fix, this);
      this.fadd = __bind(this.fadd, this);
      this.feql = __bind(this.feql, this);
      this.fun = __bind(this.fun, this);
      this.fcmp = __bind(this.fcmp, this);
      this.trap = __bind(this.trap, this);      this.mem = memory;
      this.regs = registers;
      this.processor = processor;
    }

    MMIXCommands.prototype.trap = function(X, Y, Z) {
      if (((X === Y && Y === Z) && Z === 0)) {
        return this.processor.r["break"] = 1;
      }
    };

    MMIXCommands.prototype.fcmp = function($X, $Y, $Z) {};

    MMIXCommands.prototype.fun = function(X, Y, Z) {};

    MMIXCommands.prototype.feql = function(X, Y, Z) {};

    MMIXCommands.prototype.fadd = function($X, $Y, $Z) {
      return $X.setDouble($Y.getDouble() + $Z.getDouble());
    };

    MMIXCommands.prototype.fix = function(X, Y, Z) {};

    MMIXCommands.prototype.fsub = function(X, Y, Z) {
      return $X.setDouble($Y.getDouble() - $Z.getDouble());
    };

    MMIXCommands.prototype.fixu = function(X, Y, Z) {};

    MMIXCommands.prototype.flot = function(X, Y, Z) {};

    MMIXCommands.prototype.flotu = function(X, Y, Z) {};

    MMIXCommands.prototype.sflot = function(X, Y, Z) {};

    MMIXCommands.prototype.sflotu = function(X, Y, Z) {};

    MMIXCommands.prototype.fmul = function(X, Y, Z) {
      return $X.setDouble($Y.getDouble() * $Z.getDouble());
    };

    MMIXCommands.prototype.fcmpe = function(X, Y, Z) {};

    MMIXCommands.prototype.fune = function(X, Y, Z) {};

    MMIXCommands.prototype.feqle = function(X, Y, Z) {};

    MMIXCommands.prototype.fdiv = function(X, Y, Z) {
      return $X.setDouble($Y.getDouble() / $Z.getDouble());
    };

    MMIXCommands.prototype.fsqrt = function(X, Y, Z) {};

    MMIXCommands.prototype.frem = function(X, Y, Z) {};

    MMIXCommands.prototype.fint = function(X, Y, Z) {};

    MMIXCommands.prototype.mulu = function($X, $Y_val, $Z_val, exc) {
      var $Y, $Z, i, j, x, y, z, _i, _j, _k;

      if (exc == null) {
        exc = null;
      }
      if (!$Z instanceof shared.OctaByte) {
        $Z = new shared.OctaByte(0, $Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign($Z_val);
      }
      $Y = new shared.OctaByte(0, 0);
      $Y.assign($Y_val);
      x = [0, 0, 0, 0, 0, 0, 0, 0];
      y = new Uint32Array(4);
      z = new Uint32Array(4);
      y[0] = $Y.lbyte & 0xFFFF;
      y[1] = ($Y.lbyte & 0xFFFF0000) >>> 16;
      y[2] = $Y.hbyte & 0xFFFF;
      y[3] = ($Y.hbyte & 0xFFFF0000) >>> 16;
      z[0] = $Z.lbyte & 0xFFFF;
      z[1] = ($Z.lbyte & 0xFFFF0000) >>> 16;
      z[2] = $Z.hbyte & 0xFFFF;
      z[3] = ($Z.hbyte & 0xFFFF0000) >>> 16;
      for (i = _i = 0; _i < 4; i = ++_i) {
        for (j = _j = 0; _j < 4; j = ++_j) {
          x[i + j] = x[i + j] + y[i] * z[j];
        }
      }
      for (i = _k = 0; _k < 8; i = ++_k) {
        if (x[i] > 0xFFFF) {
          x[i + 1] = x[i + 1] + ((x[i] / (1 << 16)) | 0);
          x[i] = x[i] & 0xFFFF;
        }
      }
      $X.lbyte = x[0] ^ (x[1] << 16);
      $X.hbyte = x[2] ^ (x[3] << 16);
      if (x[4] > 0 || x[5] > 0 || x[6] > 0 || x[7] > 0) {
        return exc = "overflow";
      }
    };

    MMIXCommands.prototype.mul = function($X, $Y_val, $Z_val, exc) {
      var $Y, $Z, sign;

      if (exc == null) {
        exc = null;
      }
      if (!$Z instanceof shared.OctaByte) {
        $Z = new shared.OctaByte(0, $Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign($Z_val);
      }
      $Y = new shared.OctaByte(0, 0);
      $Y.assign($Y_val);
      sign = ($Y.is_neg() && $Z.is_neg()) || (!$Y.is_neg() && !$Z.is_neg());
      if ($Y.is_neg()) {
        $Y = $Y.neg().add(1);
      }
      if ($Z.is_neg()) {
        $Z = $Z.neg().add(1);
      }
      this.mulu($X, $Y, $Z, exc);
      if ($X.hbyte > 0x7FFFFFFF) {
        exc = "overflow";
      }
      $X.hbyte = $X.hbyte & 0x7FFFFFFF;
      if (!sign) {
        return $X.assign($X.neg().add(1));
      }
    };

    MMIXCommands.prototype.add = function($X, $Y, $Z) {
      return $X.assign($Y.add($Z));
    };

    MMIXCommands.prototype.sub = function($X, $Y, $Z) {
      return $X.assign($Y.sub($Z));
    };

    MMIXCommands.prototype.ldb = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      $X.lbyte = this.mem.getByte(addr.lbyte);
      if (($X.lbyte >> 7) & 0x1 > 0) {
        $X.hbyte = 0xFFFFFFFF;
        return $X.lbyte = $X.lbyte ^ (0xFFFFFF << 8);
      } else {
        return $X.hbyte = 0x0;
      }
    };

    MMIXCommands.prototype.ldbu = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      $X.lbyte = this.mem.getByte(addr.lbyte);
      return $X.hbyte = 0x0;
    };

    MMIXCommands.prototype.ldw = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      $X.lbyte = this.mem.getWyde(addr.lbyte);
      if (($X.lbyte >> 15) & 0x1 > 0) {
        $X.hbyte = 0xFFFFFFFF;
        return $X.lbyte = $X.lbyte ^ (0xFFFF << 16);
      } else {
        return $X.hbyte = 0x0;
      }
    };

    MMIXCommands.prototype.ldwu = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      $X.lbyte = this.mem.getWyde(addr.lbyte);
      return $X.hbyte = 0x0;
    };

    MMIXCommands.prototype.ldt = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      $X.lbyte = this.mem.getTetra(addr.lbyte);
      if (($X.lbyte >> 31) & 0x1 > 0) {
        return $X.hbyte = 0xFFFFFFFF;
      } else {
        return $X.hbyte = 0x0;
      }
    };

    MMIXCommands.prototype.ldtu = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      $X.lbyte = this.mem.getTetra(addr.lbyte);
      return $X.hbyte = 0x0;
    };

    MMIXCommands.prototype.ldou = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      return $X.assign(this.mem.getOcta(addr.lbyte));
    };

    MMIXCommands.prototype.stb = function($X, $Y, $Z) {
      var addr, excOfOverflow;

      addr = $Y.add($Z);
      this.mem.setByte(addr.lbyte, $X.lbyte & 0xFF);
      if (!((($X.hbyte === 0) && (($X.lbyte >>> 8) === 0)) || ((~$X.hbyte === 0) && ((~$X.lbyte >>> 8) === 0)))) {
        return excOfOverflow = 0;
      }
    };

    MMIXCommands.prototype.stbu = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      return this.mem.setByte(addr, $X.lbyte & 0xFF);
    };

    MMIXCommands.prototype.stw = function($X, $Y, $Z) {
      var addr, excOfOverflow;

      addr = $Y.add($Z);
      this.mem.setWyde(addr.lbyte, $X.lbyte & 0xFFFF);
      if (!((($X.hbyte === 0) && (($X.lbyte >>> 16) === 0)) || ((~$X.hbyte === 0) && ((~$X.lbyte >>> 16) === 0)))) {
        return excOfOverflow = 0;
      }
    };

    MMIXCommands.prototype.stwu = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      return this.mem.setWyde(addr.lbyte, $X.lbyte & 0xFFFF);
    };

    MMIXCommands.prototype.stt = function($X, $Y, $Z) {
      var addr, excOfOverflow;

      addr = $Y.add($Z);
      this.mem.setTetra(addr.lbyte, $X.lbyte & 0xFFFFFFFF);
      if (!(($X.hbyte === 0) || (~$X.hbyte === 0))) {
        return excOfOverflow = 0;
      }
    };

    MMIXCommands.prototype.sttu = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      return this.mem.setTetra(addr.lbyte, $X.lbyte & 0xFFFFFFFF);
    };

    MMIXCommands.prototype.stou = function($X, $Y, $Z) {
      var addr;

      addr = $Y.add($Z);
      return this.mem.setOcta(addr.lbyte, $X);
    };

    MMIXCommands.prototype.or = function($X, $Y, $Z) {
      return $X.assign($Y.or($Z));
    };

    MMIXCommands.prototype.orn = function($X, $Y, $Z) {
      return $X.assign($Y.or($Z.neg()));
    };

    MMIXCommands.prototype.nor = function($X, $Y, $Z) {
      return $X.assign($Y.or($Z).neg());
    };

    MMIXCommands.prototype.xor = function($X, $Y, $Z) {
      return $X.assign($Y.xor($Z));
    };

    MMIXCommands.prototype.and = function($X, $Y, $Z) {
      return $X.assign($Y.and($Z));
    };

    MMIXCommands.prototype.andn = function($X, $Y, $Z) {
      return $X.assign($Y.and($Z.neg()));
    };

    MMIXCommands.prototype.nand = function($X, $Y, $Z) {
      return $X.assign($Y.and($Z).neg());
    };

    MMIXCommands.prototype.nxor = function($X, $Y, $Z) {
      return $X.assign($Y.xor($Z).neg());
    };

    MMIXCommands.prototype.seth = function($X, YZ) {
      $X.setH(YZ);
      $X.setMH(0x0);
      $X.setML(0x0);
      return $X.setL(0x0);
    };

    MMIXCommands.prototype.setmh = function($X, YZ) {
      $X.setH(0x0);
      $X.setMH(YZ);
      $X.setML(0x0);
      return $X.setL(0x0);
    };

    MMIXCommands.prototype.setml = function($X, YZ) {
      $X.setH(0x0);
      $X.setMH(0x0);
      $X.setML(YZ);
      return $X.setL(0x0);
    };

    MMIXCommands.prototype.setl = function($X, YZ) {
      $X.setH(0x0);
      $X.setMH(0x0);
      $X.setML(0x0);
      return $X.setL(YZ);
    };

    MMIXCommands.prototype.inch = function($X, YZ) {
      return $X.setH(($X.getH() + YZ) & 0xFFFF);
    };

    MMIXCommands.prototype.incmh = function($X, YZ) {
      return $X.setMH(($X.getMH() + YZ) & 0xFFFF);
    };

    MMIXCommands.prototype.incml = function($X, YZ) {
      return $X.setML(($X.getML() + YZ) & 0xFFFF);
    };

    MMIXCommands.prototype.incl = function($X, YZ) {
      return $X.setL(($X.getL() + YZ) & 0xFFFF);
    };

    MMIXCommands.prototype.orh = function($X, YZ) {
      return $X.setH($X.getH() | YZ);
    };

    MMIXCommands.prototype.ormh = function($X, YZ) {
      return $X.setMH($X.getMH() | YZ);
    };

    MMIXCommands.prototype.orml = function($X, YZ) {
      return $X.setML($X.getML() | YZ);
    };

    MMIXCommands.prototype.orl = function($X, YZ) {
      return $X.setL($X.getL() | YZ);
    };

    MMIXCommands.prototype.andh = function($X, YZ) {
      return $X.setH($X.getH() & !YZ);
    };

    MMIXCommands.prototype.andmh = function($X, YZ) {
      return $X.setMH($X.getMH() & !YZ);
    };

    MMIXCommands.prototype.andml = function($X, YZ) {
      return $X.setML($X.getML() & !YZ);
    };

    MMIXCommands.prototype.andl = function($X, YZ) {
      return $X.setL($X.getL() & !YZ);
    };

    return MMIXCommands;

  })();

}).call(this);

/*
//@ sourceMappingURL=mmixcommands.map
*/
