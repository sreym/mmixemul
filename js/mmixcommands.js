// Generated by CoffeeScript 1.6.3
(function() {
  var DEBUG, roundBy, shared,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DEBUG = true;

  shared = window;

  roundBy = function(val, rndMeth, rndMethDefault) {
    var Z;
    if (rndMethDefault == null) {
      rndMethDefault = 1;
    }
    if (rndMeth === 0) {
      rndMeth = rndMethDefault;
    }
    switch (rndMeth) {
      case 0:
        return Math.round(val);
      case 1:
        return Z = (val >= 0 ? Math.floor(val) : Math.ceil(val));
      case 2:
        return Math.ceil(val);
      case 3:
        return Math.floor(val);
      case 4:
        return Math.round(val);
      default:
        throw "wrong round method";
    }
  };

  shared.MMIXCommands = (function() {
    function MMIXCommands(memory, registers, processor) {
      this.jmp = __bind(this.jmp, this);
      this.nxor = __bind(this.nxor, this);
      this.nand = __bind(this.nand, this);
      this.andn = __bind(this.andn, this);
      this.and = __bind(this.and, this);
      this.xor = __bind(this.xor, this);
      this.nor = __bind(this.nor, this);
      this.orn = __bind(this.orn, this);
      this.or = __bind(this.or, this);
      this.stco = __bind(this.stco, this);
      this.stht = __bind(this.stht, this);
      this.stou = __bind(this.stou, this);
      this.sttu = __bind(this.sttu, this);
      this.stt = __bind(this.stt, this);
      this.stwu = __bind(this.stwu, this);
      this.stw = __bind(this.stw, this);
      this.stbu = __bind(this.stbu, this);
      this.stb = __bind(this.stb, this);
      this.ldou = __bind(this.ldou, this);
      this.ldtu = __bind(this.ldtu, this);
      this.ldt = __bind(this.ldt, this);
      this.ldwu = __bind(this.ldwu, this);
      this.ldw = __bind(this.ldw, this);
      this.ldbu = __bind(this.ldbu, this);
      this.ldb = __bind(this.ldb, this);
      this.zsev = __bind(this.zsev, this);
      this.zsnp = __bind(this.zsnp, this);
      this.zsnz = __bind(this.zsnz, this);
      this.zsnn = __bind(this.zsnn, this);
      this.zsod = __bind(this.zsod, this);
      this.zsp = __bind(this.zsp, this);
      this.zsz = __bind(this.zsz, this);
      this.zsn = __bind(this.zsn, this);
      this.csev = __bind(this.csev, this);
      this.csnp = __bind(this.csnp, this);
      this.csnz = __bind(this.csnz, this);
      this.csnn = __bind(this.csnn, this);
      this.csod = __bind(this.csod, this);
      this.csp = __bind(this.csp, this);
      this.csz = __bind(this.csz, this);
      this.csn = __bind(this.csn, this);
      this.bev = __bind(this.bev, this);
      this.bnp = __bind(this.bnp, this);
      this.bnz = __bind(this.bnz, this);
      this.bnn = __bind(this.bnn, this);
      this.bod = __bind(this.bod, this);
      this.bp = __bind(this.bp, this);
      this.bz = __bind(this.bz, this);
      this.bn = __bind(this.bn, this);
      this.negu = __bind(this.negu, this);
      this.neg = __bind(this.neg, this);
      this.cmpu = __bind(this.cmpu, this);
      this.cmp = __bind(this.cmp, this);
      this.sub = __bind(this.sub, this);
      this.add = __bind(this.add, this);
      this.mul = __bind(this.mul, this);
      this.mulu = __bind(this.mulu, this);
      this.fint = __bind(this.fint, this);
      this.frem = __bind(this.frem, this);
      this.fsqrt = __bind(this.fsqrt, this);
      this.fdiv = __bind(this.fdiv, this);
      this.feqle = __bind(this.feqle, this);
      this.fune = __bind(this.fune, this);
      this.fcmpe = __bind(this.fcmpe, this);
      this.fmul = __bind(this.fmul, this);
      this.sflotu = __bind(this.sflotu, this);
      this.sflot = __bind(this.sflot, this);
      this.flotu = __bind(this.flotu, this);
      this.flot = __bind(this.flot, this);
      this.fixu = __bind(this.fixu, this);
      this.fsub = __bind(this.fsub, this);
      this.fix = __bind(this.fix, this);
      this.fadd = __bind(this.fadd, this);
      this.feql = __bind(this.feql, this);
      this.fun = __bind(this.fun, this);
      this.fcmp = __bind(this.fcmp, this);
      this.trap = __bind(this.trap, this);
      this.mem = memory;
      this.regs = registers;
      this.processor = processor;
    }

    MMIXCommands.prototype.trap = function(X, Y, Z) {
      if (((X === Y && Y === Z) && Z === 0)) {
        return this.processor.r["break"] = 1;
      }
    };

    MMIXCommands.prototype.fcmp = function($X, $Y, $Z) {
      var Y, Z;
      $X.hbyte = 0;
      Y = $Y.getDouble();
      Z = $Z.getDouble();
      if (Y < Z) {
        return $X.setInt(-1);
      } else if (Y > Z) {
        return $X.setInt(1);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.fun = function($X, $Y, $Z) {
      var Y, Z;
      $X.hbyte = 0;
      Y = $Y.getDouble();
      Z = $Z.getDouble();
      if (Y === NaN || Z === NaN) {
        return $X.lbyte = 1;
      } else if (Y > Z) {
        return $X.lbyte = 0;
      }
    };

    MMIXCommands.prototype.feql = function($X, $Y, $Z) {
      var Y, Z;
      $X.hbyte = 0;
      Y = $Y.getDouble();
      Z = $Z.getDouble();
      if (Y === Z) {
        return $X.lbyte = 1;
      } else {
        return $X.lbyte = 0;
      }
    };

    MMIXCommands.prototype.fadd = function($X, $Y, $Z) {
      return $X.setDouble($Y.getDouble() + $Z.getDouble());
    };

    MMIXCommands.prototype.fix = function($X, Y, $Z) {
      var Z;
      Z = $Z.getDouble();
      Z = roundBy(Z, Y);
      if (Z < -Math.pow(2, 63) || Z > Math.pow(2, 63)) {
        throw "wrong number in FIX";
      }
      $X.lbyte = Z & 0xFFFFFFFF;
      $X.hbyte = (Z / Math.pow(2, 32)) & 0xFFFFFFFF;
      if (Z < 0) {
        return $X.assign($X.neg().add(1));
      }
    };

    MMIXCommands.prototype.fsub = function($X, $Y, $Z) {
      return $X.setDouble($Y.getDouble() - $Z.getDouble());
    };

    MMIXCommands.prototype.fixu = function($X, Y, $Z) {
      var Z;
      Z = $Z.getDouble();
      Z = roundBy(Z, Y);
      $X.lbyte = Z & 0xFFFFFFFF;
      return $X.hbyte = (Z / Math.pow(2, 32)) & 0xFFFFFFFF;
    };

    MMIXCommands.prototype.flot = function($X, Y, Z_val) {
      var $Z, extra, extraShift, neg, number;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Z.is_neg()) {
        neg = true;
        $Z.assign($Z.neg().add(1));
      } else {
        neg = false;
      }
      extra = ($Z.hbyte >>> 21) & 0x3FF;
      extraShift = 0;
      while (extra !== 0) {
        extra = extra / 2 | 0;
        extraShift++;
      }
      number = (($Z.hbyte & 0x7FFFFFFF) * Math.pow(2, 32 - extraShift)) + ($Z.lbyte >>> extraShift);
      number *= Math.pow(2, extraShift);
      if (neg) {
        number *= -1;
      }
      return $X.setDouble(number);
    };

    MMIXCommands.prototype.flotu = function($X, Y, Z_val) {
      var $Z, extra, extraShift, number;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      extra = $Z.hbyte >>> 21;
      extraShift = 0;
      while (extra !== 0) {
        extra = extra / 2 | 0;
        extraShift++;
      }
      number = (($Z.hbyte & 0x7FFFFFFF) * Math.pow(2, 32 - extraShift)) + ($Z.lbyte >>> extraShift);
      number *= Math.pow(2, extraShift);
      return $X.setDouble(number);
    };

    MMIXCommands.prototype.sflot = function($X, Y, $Z) {};

    MMIXCommands.prototype.sflotu = function($X, Y, $Z) {};

    MMIXCommands.prototype.fmul = function($X, $Y, $Z) {
      return $X.setDouble($Y.getDouble() * $Z.getDouble());
    };

    MMIXCommands.prototype.fcmpe = function($X, $Y, $Z) {
      var Y, Z;
      $X.hbyte = 0;
      Y = $Y.getDouble();
      Z = $Z.getDouble();
      if (Y - this.processor.r.rE < Z) {
        return $X.lbyte = 0xFFFFFFFF;
      } else if (Y + this.processor.r.rE > Z) {
        return $X.lbyte = 1;
      } else {
        return $X.lbyte = 0;
      }
    };

    MMIXCommands.prototype.fune = function($X, $Y, $Z) {
      var Y, Z;
      $X.hbyte = 0;
      Y = $Y.getDouble();
      Z = $Z.getDouble();
      if (Y === NaN || Z === NaN) {
        return $X.lbyte = 1;
      } else if (Y > Z) {
        return $X.lbyte = 0;
      }
    };

    MMIXCommands.prototype.feqle = function($X, $Y, $Z) {
      var Y, Z;
      $X.hbyte = 0;
      Y = $Y.getDouble();
      Z = $Z.getDouble();
      if (Y + this.processor.r.rE < Z && Y - this.processor.r.rE > Z) {
        return $X.lbyte = 1;
      } else {
        return $X.lbyte = 0;
      }
    };

    MMIXCommands.prototype.fdiv = function($X, $Y, $Z) {
      return $X.setDouble($Y.getDouble() / $Z.getDouble());
    };

    MMIXCommands.prototype.fsqrt = function($X, Y, $Z) {
      var Z;
      Z = $Z.getDouble();
      Z = Math.sqrt(Z);
      if (Y > 1) {
        Z = roundBy(Z, Y);
      }
      return $X.setDouble(Z);
    };

    MMIXCommands.prototype.frem = function($X, $Y, $Z) {
      var Y, Z, n1, n2, res;
      Y = $Y.getDouble();
      Z = $Z.getDouble();
      n1 = Math.ceil(Y / Z);
      n2 = Math.floor(Y / Z);
      if (Math.abs(Y / Z - (Y - n1 * Z)) < Math.abs(Y / Z - (Y - n2 * Z))) {
        res = n1;
      } else {
        res = n2;
      }
      return $X.setInt(res);
    };

    MMIXCommands.prototype.fint = function($X, Y, $Z) {
      var Z;
      Z = $Z.getDouble();
      Z = roundBy(Z, Y);
      return $X.setDouble(Z);
    };

    MMIXCommands.prototype.mulu = function($X, $Y_val, Z_val, exc) {
      var $Y, $Z, i, j, x, y, z, _i, _j, _k;
      if (exc == null) {
        exc = null;
      }
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      $Y = new shared.OctaByte(0, 0);
      $Y.assign($Y_val);
      x = [0, 0, 0, 0, 0, 0, 0, 0];
      y = new Uint32Array(4);
      z = new Uint32Array(4);
      y[0] = $Y.lbyte & 0xFFFF;
      y[1] = ($Y.lbyte & 0xFFFF0000) >>> 16;
      y[2] = $Y.hbyte & 0xFFFF;
      y[3] = ($Y.hbyte & 0xFFFF0000) >>> 16;
      z[0] = $Z.lbyte & 0xFFFF;
      z[1] = ($Z.lbyte & 0xFFFF0000) >>> 16;
      z[2] = $Z.hbyte & 0xFFFF;
      z[3] = ($Z.hbyte & 0xFFFF0000) >>> 16;
      for (i = _i = 0; _i < 4; i = ++_i) {
        for (j = _j = 0; _j < 4; j = ++_j) {
          x[i + j] = x[i + j] + y[i] * z[j];
        }
      }
      for (i = _k = 0; _k < 8; i = ++_k) {
        if (x[i] > 0xFFFF) {
          x[i + 1] = x[i + 1] + ((x[i] / (1 << 16)) | 0);
          x[i] = x[i] & 0xFFFF;
        }
      }
      $X.lbyte = x[0] ^ (x[1] << 16);
      $X.hbyte = x[2] ^ (x[3] << 16);
      if (x[4] > 0 || x[5] > 0 || x[6] > 0 || x[7] > 0) {
        return exc = "overflow";
      }
    };

    MMIXCommands.prototype.mul = function($X, $Y_val, Z_val, exc) {
      var $Y, $Z, sign;
      if (exc == null) {
        exc = null;
      }
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      $Y = new shared.OctaByte(0, 0);
      $Y.assign($Y_val);
      sign = ($Y.is_neg() && $Z.is_neg()) || (!$Y.is_neg() && !$Z.is_neg());
      if ($Y.is_neg()) {
        $Y = $Y.neg().add(1);
      }
      if ($Z.is_neg()) {
        $Z = $Z.neg().add(1);
      }
      this.mulu($X, $Y, $Z, exc);
      if ($X.hbyte > 0x7FFFFFFF) {
        exc = "overflow";
      }
      $X.hbyte = $X.hbyte & 0x7FFFFFFF;
      if (!sign) {
        return $X.assign($X.neg().add(1));
      }
    };

    MMIXCommands.prototype.add = function($X, $Y, $Z) {
      return $X.assign($Y.add($Z));
    };

    MMIXCommands.prototype.sub = function($X, $Y, $Z) {
      return $X.assign($Y.sub($Z));
    };

    MMIXCommands.prototype.cmp = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      switch ($Y.cmp($Z)) {
        case -1:
          return $X.setInt(-1);
        case 1:
          return $X.setInt(1);
        default:
          return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.cmpu = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      switch ($Y.cmpu($Z)) {
        case -1:
          return $X.setInt(-1);
        case 1:
          return $X.setInt(1);
        default:
          return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.neg = function($X, Y, Z_val) {
      var $Y, $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      $Y = new shared.OctaByte(0, Y);
      return $X.assign($Y.sub($Z));
    };

    MMIXCommands.prototype.negu = function($X, Y, Z_val) {
      var $Y, $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      return $Y = new shared.OctaByte(0, Y);
    };

    MMIXCommands.prototype.bn = function($X, YZ) {
      if ($X.cmp(new shared.OctaByte(0, 0)) === -1) {
        return this.processor.r.curEx += 4 * YZ;
      }
    };

    MMIXCommands.prototype.bz = function($X, YZ) {
      if ($X.cmp(new shared.OctaByte(0, 0)) === 0) {
        return this.processor.r.curEx += 4 * YZ;
      }
    };

    MMIXCommands.prototype.bp = function($X, YZ) {
      if ($X.cmp(new shared.OctaByte(0, 0)) === 1) {
        return this.processor.r.curEx += 4 * YZ;
      }
    };

    MMIXCommands.prototype.bod = function($X, YZ) {
      if ($X.lbyte & 0x1 !== 0) {
        return this.processor.r.curEx += 4 * YZ;
      }
    };

    MMIXCommands.prototype.bnn = function($X, YZ) {
      if ($X.cmp(new shared.OctaByte(0, 0)) !== -1) {
        return this.processor.r.curEx += 4 * YZ;
      }
    };

    MMIXCommands.prototype.bnz = function($X, YZ) {
      if ($X.cmp(new shared.OctaByte(0, 0)) !== 0) {
        return this.processor.r.curEx += 4 * YZ;
      }
    };

    MMIXCommands.prototype.bnp = function($X, YZ) {
      if ($X.cmp(new shared.OctaByte(0, 0)) !== 1) {
        return this.processor.r.curEx += 4 * YZ;
      }
    };

    MMIXCommands.prototype.bev = function($X, YZ) {
      if ($X.lbyte & 0x1 === 0) {
        return this.processor.r.curEx += 4 * YZ;
      }
    };

    MMIXCommands.prototype.csn = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.is_neg()) {
        return $X.assign($Z);
      }
    };

    MMIXCommands.prototype.csz = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) === 0) {
        return $X.assign($Z);
      }
    };

    MMIXCommands.prototype.csp = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) === 1) {
        return $X.assign($Z);
      }
    };

    MMIXCommands.prototype.csod = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.lbyte & 0x1 !== 0) {
        return $X.assign($Z);
      }
    };

    MMIXCommands.prototype.csnn = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) !== -1) {
        return $X.assign($Z);
      }
    };

    MMIXCommands.prototype.csnz = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) !== 0) {
        return $X.assign($Z);
      }
    };

    MMIXCommands.prototype.csnp = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) !== 1) {
        return $X.assign($Z);
      }
    };

    MMIXCommands.prototype.csev = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.lbyte & 0x1 === 0) {
        return $X.assign($Z);
      }
    };

    MMIXCommands.prototype.zsn = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.is_neg()) {
        return $X.assign($Z);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.zsz = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) === 0) {
        return $X.assign($Z);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.zsp = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) === 1) {
        return $X.assign($Z);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.zsod = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.lbyte & 0x1 !== 0) {
        return $X.assign($Z);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.zsnn = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) !== -1) {
        return $X.assign($Z);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.zsnz = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) !== 0) {
        return $X.assign($Z);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.zsnp = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.cmp(new shared.OctaByte(0, 0)) !== 1) {
        return $X.assign($Z);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.zsev = function($X, $Y, Z_val) {
      var $Z;
      if (!(Z_val instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z_val);
      } else {
        $Z = new shared.OctaByte(0, 0);
        $Z.assign(Z_val);
      }
      if ($Y.lbyte & 0x1 === 0) {
        return $X.assign($Z);
      } else {
        return $X.setInt(0);
      }
    };

    MMIXCommands.prototype.ldb = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      $X.lbyte = this.mem.getByte(addr.lbyte);
      if (($X.lbyte >> 7) & 0x1 > 0) {
        $X.hbyte = 0xFFFFFFFF;
        return $X.lbyte = $X.lbyte ^ (0xFFFFFF << 8);
      } else {
        return $X.hbyte = 0x0;
      }
    };

    MMIXCommands.prototype.ldbu = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      $X.lbyte = this.mem.getByte(addr.lbyte);
      return $X.hbyte = 0x0;
    };

    MMIXCommands.prototype.ldw = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      $X.lbyte = this.mem.getWyde(addr.lbyte);
      if (($X.lbyte >> 15) & 0x1 > 0) {
        $X.hbyte = 0xFFFFFFFF;
        return $X.lbyte = $X.lbyte ^ (0xFFFF << 16);
      } else {
        return $X.hbyte = 0x0;
      }
    };

    MMIXCommands.prototype.ldwu = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      $X.lbyte = this.mem.getWyde(addr.lbyte);
      return $X.hbyte = 0x0;
    };

    MMIXCommands.prototype.ldt = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      $X.lbyte = this.mem.getTetra(addr.lbyte);
      if (($X.lbyte >> 31) & 0x1 > 0) {
        return $X.hbyte = 0xFFFFFFFF;
      } else {
        return $X.hbyte = 0x0;
      }
    };

    MMIXCommands.prototype.ldtu = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      $X.lbyte = this.mem.getTetra(addr.lbyte);
      return $X.hbyte = 0x0;
    };

    MMIXCommands.prototype.ldou = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      return $X.assign(this.mem.getOcta(addr.lbyte));
    };

    MMIXCommands.prototype.stb = function($X, $Y, $Z) {
      var addr, excOfOverflow;
      addr = $Y.add($Z);
      this.mem.setByte(addr.lbyte, $X.lbyte & 0xFF);
      if (!((($X.hbyte === 0) && (($X.lbyte >>> 8) === 0)) || ((~$X.hbyte === 0) && ((~$X.lbyte >>> 8) === 0)))) {
        return excOfOverflow = 0;
      }
    };

    MMIXCommands.prototype.stbu = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      return this.mem.setByte(addr.lbyte, $X.lbyte & 0xFF);
    };

    MMIXCommands.prototype.stw = function($X, $Y, $Z) {
      var addr, excOfOverflow;
      addr = $Y.add($Z);
      this.mem.setWyde(addr.lbyte, $X.lbyte & 0xFFFF);
      if (!((($X.hbyte === 0) && (($X.lbyte >>> 16) === 0)) || ((~$X.hbyte === 0) && ((~$X.lbyte >>> 16) === 0)))) {
        return excOfOverflow = 0;
      }
    };

    MMIXCommands.prototype.stwu = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      return this.mem.setWyde(addr.lbyte, $X.lbyte & 0xFFFF);
    };

    MMIXCommands.prototype.stt = function($X, $Y, $Z) {
      var addr, excOfOverflow;
      addr = $Y.add($Z);
      this.mem.setTetra(addr.lbyte, $X.lbyte & 0xFFFFFFFF);
      if (!(($X.hbyte === 0) || (~$X.hbyte === 0))) {
        return excOfOverflow = 0;
      }
    };

    MMIXCommands.prototype.sttu = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      return this.mem.setTetra(addr.lbyte, $X.lbyte & 0xFFFFFFFF);
    };

    MMIXCommands.prototype.stou = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      return this.mem.setOcta(addr.lbyte, $X);
    };

    MMIXCommands.prototype.stht = function($X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      return this.mem.setTetra(addr.lbyte, $X.hbyte & 0xFFFFFFFF);
    };

    MMIXCommands.prototype.stco = function(X, $Y, $Z) {
      var addr;
      addr = $Y.add($Z);
      return this.mem.setOcta(addr.lbyte, new shared.OctaByte(0, X));
    };

    MMIXCommands.prototype.or = function($X, $Y, Z) {
      var $Z;
      if (!(Z instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z);
      } else {
        $Z = new shared.OctaByte(Z.hbyte, Z.lbyte);
      }
      return $X.assign($Y.or($Z));
    };

    MMIXCommands.prototype.orn = function($X, $Y, Z) {
      var $Z;
      if (!(Z instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z);
      } else {
        $Z = new shared.OctaByte(Z.hbyte, Z.lbyte);
      }
      return $X.assign($Y.or($Z.neg()));
    };

    MMIXCommands.prototype.nor = function($X, $Y, Z) {
      var $Z;
      if (!(Z instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z);
      } else {
        $Z = new shared.OctaByte(Z.hbyte, Z.lbyte);
      }
      return $X.assign($Y.or($Z).neg());
    };

    MMIXCommands.prototype.xor = function($X, $Y, Z) {
      var $Z;
      if (!(Z instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z);
      } else {
        $Z = new shared.OctaByte(Z.hbyte, Z.lbyte);
      }
      return $X.assign($Y.xor($Z));
    };

    MMIXCommands.prototype.and = function($X, $Y, Z) {
      var $Z;
      if (!(Z instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z);
      } else {
        $Z = new shared.OctaByte(Z.hbyte, Z.lbyte);
      }
      return $X.assign($Y.and($Z));
    };

    MMIXCommands.prototype.andn = function($X, $Y, Z) {
      var $Z;
      if (!(Z instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z);
      } else {
        $Z = new shared.OctaByte(Z.hbyte, Z.lbyte);
      }
      return $X.assign($Y.and($Z.neg()));
    };

    MMIXCommands.prototype.nand = function($X, $Y, Z) {
      var $Z;
      if (!(Z instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z);
      } else {
        $Z = new shared.OctaByte(Z.hbyte, Z.lbyte);
      }
      return $X.assign($Y.and($Z).neg());
    };

    MMIXCommands.prototype.nxor = function($X, $Y, Z) {
      var $Z;
      if (!(Z instanceof shared.OctaByte)) {
        $Z = new shared.OctaByte(0, Z);
      } else {
        $Z = new shared.OctaByte(Z.hbyte, Z.lbyte);
      }
      return $X.assign($Y.xor($Z).neg());
    };

    MMIXCommands.prototype.seth = function($X, YZ) {
      $X.setH(YZ);
      $X.setMH(0x0);
      $X.setML(0x0);
      return $X.setL(0x0);
    };

    MMIXCommands.prototype.setmh = function($X, YZ) {
      $X.setH(0x0);
      $X.setMH(YZ);
      $X.setML(0x0);
      return $X.setL(0x0);
    };

    MMIXCommands.prototype.setml = function($X, YZ) {
      $X.setH(0x0);
      $X.setMH(0x0);
      $X.setML(YZ);
      return $X.setL(0x0);
    };

    MMIXCommands.prototype.setl = function($X, YZ) {
      $X.setH(0x0);
      $X.setMH(0x0);
      $X.setML(0x0);
      return $X.setL(YZ);
    };

    MMIXCommands.prototype.inch = function($X, YZ) {
      return $X.setH(($X.getH() + YZ) & 0xFFFF);
    };

    MMIXCommands.prototype.incmh = function($X, YZ) {
      return $X.setMH(($X.getMH() + YZ) & 0xFFFF);
    };

    MMIXCommands.prototype.incml = function($X, YZ) {
      return $X.setML(($X.getML() + YZ) & 0xFFFF);
    };

    MMIXCommands.prototype.incl = function($X, YZ) {
      return $X.setL(($X.getL() + YZ) & 0xFFFF);
    };

    MMIXCommands.prototype.orh = function($X, YZ) {
      return $X.setH($X.getH() | YZ);
    };

    MMIXCommands.prototype.ormh = function($X, YZ) {
      return $X.setMH($X.getMH() | YZ);
    };

    MMIXCommands.prototype.orml = function($X, YZ) {
      return $X.setML($X.getML() | YZ);
    };

    MMIXCommands.prototype.orl = function($X, YZ) {
      return $X.setL($X.getL() | YZ);
    };

    MMIXCommands.prototype.andh = function($X, YZ) {
      return $X.setH($X.getH() & !YZ);
    };

    MMIXCommands.prototype.andmh = function($X, YZ) {
      return $X.setMH($X.getMH() & !YZ);
    };

    MMIXCommands.prototype.andml = function($X, YZ) {
      return $X.setML($X.getML() & !YZ);
    };

    MMIXCommands.prototype.andl = function($X, YZ) {
      return $X.setL($X.getL() & !YZ);
    };

    MMIXCommands.prototype.jmp = function(XYZ) {
      return this.processor.r.curEx += 4 * XYZ;
    };

    return MMIXCommands;

  })();

}).call(this);

/*
//@ sourceMappingURL=mmixcommands.map
*/
